# Python venv wrapper
#
# Scheme B (recommended):
# - Central venv lives at: $VENV_HOME/<name>
# - Project venv is:       <project>/.venv  -> symlink to $VENV_HOME/<name>
# - Registry records:      <name> -> <project>/.venv (symlink)
#
# Goals:
# - LSP/pyright always finds a project-local .venv
# - Human workflows remain simple: mkvenv/venv/rmvenv/venvls
# - Be safe by default (never delete a real project .venv directory automatically)

export VENV_HOME="$HOME/venvs"
[[ -d "$VENV_HOME" ]] || mkdir -p "$VENV_HOME"

# Registry format: tab-separated "name\t/path/to/project/.venv" (which may be a symlink)
export VENV_REGISTRY_FILE="$VENV_HOME/registry.tsv"
[[ -f "$VENV_REGISTRY_FILE" ]] || : >| "$VENV_REGISTRY_FILE"

_venv_python_bin() {
  # Prefer python3 if available; fall back to python.
  # (Avoid pinning python3.11: that increases surprise when system Python updates.)
  if command -v python3 >/dev/null 2>&1; then
    echo python3
  else
    echo python
  fi
}

_venv_central_path() {
  local name="$1"
  echo "$VENV_HOME/$name"
}

_venv_registry_get() {
  local name="$1"
  awk -F'\t' -v n="$name" '$1==n {print $2; exit}' "$VENV_REGISTRY_FILE" 2>/dev/null
}

_venv_registry_set() {
  # upsert name -> path
  local name="$1"; shift
  local path="$1"; shift

  local tmp
  tmp="${VENV_REGISTRY_FILE}.tmp.$$"
  awk -F'\t' -v n="$name" '$1!=n' "$VENV_REGISTRY_FILE" 2>/dev/null >| "$tmp" || :
  printf "%s\t%s\n" "$name" "$path" >> "$tmp"
  /bin/mv "$tmp" "$VENV_REGISTRY_FILE"
}

_venv_registry_del() {
  local name="$1"
  local tmp
  tmp="${VENV_REGISTRY_FILE}.tmp.$$"
  awk -F'\t' -v n="$name" '$1!=n' "$VENV_REGISTRY_FILE" 2>/dev/null >| "$tmp" || :
  /bin/mv "$tmp" "$VENV_REGISTRY_FILE"
}

_venv_safe_rm() {
  # Use trash if available.
  local p="$1"
  if command -v trash >/dev/null 2>&1; then
    trash "$p"
  else
    rm -rf "$p"
  fi
}

# Back-compat: list by directory (old style)
lsvenv() {
  ls -1 "$VENV_HOME" 2>/dev/null
}

# List registry (name + path)
venvls() {
  if [[ ! -s "$VENV_REGISTRY_FILE" ]]; then
    echo "(no venvs recorded)"
    return 0
  fi
  column -t -s $'\t' "$VENV_REGISTRY_FILE"
}

# Show resolved paths for a name (debug)
venvwhere() {
  if [ $# -eq 0 ]; then
    echo "Usage: venvwhere <name>"
    return 1
  fi

  local name="$1"
  local reg
  reg="$(_venv_registry_get "$name")"
  local central
  central="$(_venv_central_path "$name")"

  echo "name:    $name"
  echo "central: $central"
  echo "record:  ${reg:-<none>}"
  if [[ -n "$reg" ]]; then
    echo "record-resolved: $(/usr/bin/readlink "$reg" 2>/dev/null || echo "<not a symlink>")"
  fi
}

# Activate venv by name:
# - Prefer registry path (<project>/.venv) if it exists.
# - If registry points to a symlink that is missing, try to relink to central.
# - Fallback to central venv ($VENV_HOME/<name>)
venv() {
  if [ $# -eq 0 ]; then
    echo "Please provide venv name"
    return 1
  fi

  local name="$1"
  local reg
  reg="$(_venv_registry_get "$name")"
  local central
  central="$(_venv_central_path "$name")"

  # 1) Registry path
  if [[ -n "$reg" ]]; then
    if [[ -f "$reg/bin/activate" ]]; then
      source "$reg/bin/activate"
      return $?
    fi

    # If it's a symlink but broken, relink it.
    if [[ -L "$reg" && -d "$central" && -f "$central/bin/activate" ]]; then
      /bin/rm -f "$reg"
      /bin/ln -s "$central" "$reg"
      source "$reg/bin/activate"
      return $?
    fi
  fi

  # 2) Central venv
  if [[ -f "$central/bin/activate" ]]; then
    source "$central/bin/activate"
    return $?
  fi

  echo "venv: not found: $name"
  echo "  - registry: $VENV_REGISTRY_FILE"
  echo "  - record:   ${reg:-<none>}"
  echo "  - central:  $central"
  return 1
}

# Create / link a venv for the CURRENT project:
#   mkvenv <name>
mkvenv() {
  if [ $# -eq 0 ]; then
    echo "Please provide venv name"
    return 1
  fi

  local name="$1"
  local proj_dir
  proj_dir="$(pwd -P)"
  local proj_venv="$proj_dir/.venv"
  local central
  central="$(_venv_central_path "$name")"

  local pybin
  pybin="$(_venv_python_bin)"

  # 1) Ensure central venv exists
  if [[ -d "$central" && -f "$central/bin/activate" ]]; then
    :
  else
    "$pybin" -m venv "$central" || return $?
    echo "mkvenv: created central venv: $central (via $pybin)"
  fi

  # 2) Ensure project .venv points to central
  if [[ -L "$proj_venv" ]]; then
    /bin/rm -f "$proj_venv"
    /bin/ln -s "$central" "$proj_venv"
    echo "mkvenv: updated symlink: $proj_venv -> $central"
  elif [[ -d "$proj_venv" ]]; then
    # Don't delete automatically.
    echo "mkvenv: project .venv already exists (directory): $proj_venv"
    echo "  scheme B prefers a symlink to: $central"
    echo "  migrate option (manual): mv .venv .venv.bak && ln -s '$central' .venv"
  else
    /bin/rm -rf "$proj_venv" 2>/dev/null || :
    /bin/ln -s "$central" "$proj_venv"
    echo "mkvenv: linked: $proj_venv -> $central"
  fi

  # 3) Record registry as project .venv
  _venv_registry_set "$name" "$proj_venv"
  echo "mkvenv: recorded $name -> $proj_venv"
}

# Record an existing project .venv for a name (no creation)
venvadd() {
  if [ $# -eq 0 ]; then
    echo "Usage: venvadd <name> [project_dir]"
    return 1
  fi

  local name="$1"
  local proj_dir
  proj_dir="${2:-$(pwd -P)}"
  local proj_venv="$proj_dir/.venv"

  if [[ ! -e "$proj_venv" ]]; then
    echo "venvadd: missing: $proj_venv"
    return 1
  fi

  _venv_registry_set "$name" "$proj_venv"
  echo "venvadd: recorded $name -> $proj_venv"
}

# Recreate project .venv symlink for a name based on current directory
venvfix() {
  if [ $# -eq 0 ]; then
    echo "Usage: venvfix <name>"
    return 1
  fi

  local name="$1"
  local proj_dir
  proj_dir="$(pwd -P)"
  local proj_venv="$proj_dir/.venv"
  local central
  central="$(_venv_central_path "$name")"

  if [[ ! -d "$central" || ! -f "$central/bin/activate" ]]; then
    echo "venvfix: central venv missing: $central"
    return 1
  fi

  if [[ -d "$proj_venv" && ! -L "$proj_venv" ]]; then
    echo "venvfix: refusing to overwrite real directory: $proj_venv"
    return 1
  fi

  /bin/rm -f "$proj_venv" 2>/dev/null || :
  /bin/ln -s "$central" "$proj_venv"
  _venv_registry_set "$name" "$proj_venv"
  echo "venvfix: linked + recorded $name -> $proj_venv"
}

# Remove by name:
# - Removes registry entry
# - Removes project .venv symlink IF it is a symlink
# - Removes central venv directory ($VENV_HOME/<name>)
rmvenv() {
  if [ $# -eq 0 ]; then
    echo "Please provide venv name"
    return 1
  fi

  local name="$1"
  local reg
  reg="$(_venv_registry_get "$name")"
  local central
  central="$(_venv_central_path "$name")"

  # Remove project link (only if symlink)
  if [[ -n "$reg" ]]; then
    if [[ -L "$reg" ]]; then
      /bin/rm -f "$reg"
      echo "rmvenv: removed project symlink $reg"
    elif [[ -e "$reg" ]]; then
      echo "rmvenv: registry points to a real path (not symlink); not deleting: $reg"
    fi
    _venv_registry_del "$name"
    echo "rmvenv: removed registry entry for $name"
  fi

  # Remove central venv
  if [[ -d "$central" ]]; then
    _venv_safe_rm "$central"
    echo "rmvenv: removed central venv $central"
    return 0
  fi

  # Legacy fallback
  if [[ -d "$VENV_HOME/$name" ]]; then
    _venv_safe_rm "$VENV_HOME/$name"
    echo "rmvenv: removed legacy venv $VENV_HOME/$name"
    return 0
  fi

  echo "rmvenv: not found: $name"
  return 1
}
