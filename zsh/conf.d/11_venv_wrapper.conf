export VENV_HOME="$HOME/venvs"
[[ -d $VENV_HOME ]] || mkdir -p "$VENV_HOME"

# Registry format: tab-separated "name\t/path/to/project/.venv"
export VENV_REGISTRY_FILE="$VENV_HOME/registry.tsv"
[[ -f "$VENV_REGISTRY_FILE" ]] || : >| "$VENV_REGISTRY_FILE"

_venv_python_bin() {
  # keep old behavior preference (python3.11) if available, otherwise python3
  if command -v python3.11 >/dev/null 2>&1; then
    echo python3.11
  else
    echo python3
  fi
}

_venv_registry_get() {
  # prints path for a given name
  local name="$1"
  awk -F'\t' -v n="$name" '$1==n {print $2; exit}' "$VENV_REGISTRY_FILE" 2>/dev/null
}

_venv_registry_set() {
  # upsert name -> path
  local name="$1"; shift
  local path="$1"; shift

  # write to temp then replace (avoid clobber on error)
  local tmp="${VENV_REGISTRY_FILE}.tmp.$$"
  awk -F'\t' -v n="$name" '$1!=n' "$VENV_REGISTRY_FILE" 2>/dev/null >| "$tmp" || :
  printf "%s\t%s\n" "$name" "$path" >> "$tmp"
  /bin/mv "$tmp" "$VENV_REGISTRY_FILE"
}

_venv_registry_del() {
  local name="$1"
  local tmp="${VENV_REGISTRY_FILE}.tmp.$$"
  awk -F'\t' -v n="$name" '$1!=n' "$VENV_REGISTRY_FILE" 2>/dev/null >| "$tmp" || :
  /bin/mv "$tmp" "$VENV_REGISTRY_FILE"
}

# Back-compat: list by directory (old style)
lsvenv() {
  ls -1 "$VENV_HOME" 2>/dev/null
}

# New: list registry (name + path)
venvls() {
  if [[ ! -s "$VENV_REGISTRY_FILE" ]]; then
    echo "(no venvs recorded)"
    return 0
  fi
  # nice aligned output
  column -t -s $'\t' "$VENV_REGISTRY_FILE"
}

# Activate venv by recorded name (new behavior).
# If not found in registry, fall back to old layout: $VENV_HOME/<name>
venv() {
  if [ $# -eq 0 ]; then
    echo "Please provide venv name"
    return 1
  fi

  local name="$1"
  local venv_path
  venv_path="$(_venv_registry_get "$name")"

  if [[ -n "$venv_path" && -f "$venv_path/bin/activate" ]]; then
    source "$venv_path/bin/activate"
    return $?
  fi

  if [[ -f "$VENV_HOME/$name/bin/activate" ]]; then
    source "$VENV_HOME/$name/bin/activate"
    return $?
  fi

  echo "venv: not found: $name"
  echo "  - registry: $VENV_REGISTRY_FILE"
  echo "  - checked:  $venv_path"
  echo "  - legacy:   $VENV_HOME/$name"
  return 1
}

# Create venv in a central location and link it into CURRENT DIRECTORY as .venv:
#   mkvenv <name>
#
# Scheme B (recommended):
# - Central venv lives at: $VENV_HOME/<name>
# - Project venv is:       $(pwd)/.venv  -> symlink to $VENV_HOME/<name>
# - Registry records:      <name> -> $(pwd)/.venv
mkvenv() {
  if [ $# -eq 0 ]; then
    echo "Please provide venv name"
    return 1
  fi

  local name="$1"
  local proj_dir
  proj_dir="$(pwd -P)"
  local proj_venv="$proj_dir/.venv"
  local central_venv="$VENV_HOME/$name"

  local pybin
  pybin="$(_venv_python_bin)"

  # 1) Ensure central venv exists
  if [[ -d "$central_venv" && -f "$central_venv/bin/activate" ]]; then
    :
  else
    "$pybin" -m venv "$central_venv" || return $?
    echo "mkvenv: created central venv: $central_venv (via $pybin)"
  fi

  # 2) Ensure project .venv points to central venv
  if [[ -L "$proj_venv" ]]; then
    # If it's a symlink, replace it to ensure it points correctly
    /bin/rm -f "$proj_venv"
    /bin/ln -s "$central_venv" "$proj_venv"
    echo "mkvenv: updated symlink: $proj_venv -> $central_venv"
  elif [[ -d "$proj_venv" && -f "$proj_venv/bin/activate" ]]; then
    # Existing real venv in project: don't delete automatically
    echo "mkvenv: project .venv already exists (directory): $proj_venv"
    echo "  (scheme B prefers a symlink to $central_venv; migrate manually if desired)"
  else
    # Missing or non-venv path
    /bin/rm -rf "$proj_venv" 2>/dev/null || :
    /bin/ln -s "$central_venv" "$proj_venv"
    echo "mkvenv: linked: $proj_venv -> $central_venv"
  fi

  # 3) Record registry as project .venv (LSP-friendly)
  _venv_registry_set "$name" "$proj_venv"
  echo "mkvenv: recorded $name -> $proj_venv"
}

# Remove by name: deletes the recorded .venv directory (if present) and removes registry entry.
rmvenv() {
  if [ $# -eq 0 ]; then
    echo "Please provide venv name"
    return 1
  fi

  local name="$1"
  local venv_path
  venv_path="$(_venv_registry_get "$name")"

  if [[ -n "$venv_path" ]]; then
    if [[ -d "$venv_path" && -f "$venv_path/bin/activate" ]]; then
      # Delete the recorded venv directory (matches original "delete record + directory" behavior)
      if command -v trash >/dev/null 2>&1; then
        trash "$venv_path"
        echo "rmvenv: trashed $venv_path"
      else
        rm -rf "$venv_path"
        echo "rmvenv: removed $venv_path"
      fi
    else
      echo "rmvenv: recorded path is missing or not a venv dir (skipped delete): $venv_path"
    fi
    _venv_registry_del "$name"
    echo "rmvenv: removed registry entry for $name"
    return 0
  fi

  # Legacy fallback
  if [[ -d "$VENV_HOME/$name" ]]; then
    rm -rf "$VENV_HOME/$name"
    echo "rmvenv: removed legacy venv $VENV_HOME/$name"
    return 0
  fi

  echo "rmvenv: not found: $name"
  return 1
}
