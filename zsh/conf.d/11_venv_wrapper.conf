export VENV_HOME="$HOME/venvs"
[[ -d $VENV_HOME ]] || mkdir -p "$VENV_HOME"

# Registry format: tab-separated "name\t/path/to/project/.venv"
export VENV_REGISTRY_FILE="$VENV_HOME/registry.tsv"
[[ -f "$VENV_REGISTRY_FILE" ]] || : >| "$VENV_REGISTRY_FILE"

_venv_python_bin() {
  # keep old behavior preference (python3.11) if available, otherwise python3
  if command -v python3.11 >/dev/null 2>&1; then
    echo python3.11
  else
    echo python3
  fi
}

_venv_registry_get() {
  # prints path for a given name
  local name="$1"
  awk -F'\t' -v n="$name" '$1==n {print $2; exit}' "$VENV_REGISTRY_FILE" 2>/dev/null
}

_venv_registry_set() {
  # upsert name -> path
  local name="$1"; shift
  local path="$1"; shift

  # write to temp then replace (avoid clobber on error)
  local tmp="${VENV_REGISTRY_FILE}.tmp.$$"
  awk -F'\t' -v n="$name" '$1!=n' "$VENV_REGISTRY_FILE" 2>/dev/null >| "$tmp" || :
  printf "%s\t%s\n" "$name" "$path" >> "$tmp"
  /bin/mv "$tmp" "$VENV_REGISTRY_FILE"
}

_venv_registry_del() {
  local name="$1"
  local tmp="${VENV_REGISTRY_FILE}.tmp.$$"
  awk -F'\t' -v n="$name" '$1!=n' "$VENV_REGISTRY_FILE" 2>/dev/null >| "$tmp" || :
  /bin/mv "$tmp" "$VENV_REGISTRY_FILE"
}

# Back-compat: list by directory (old style)
lsvenv() {
  ls -1 "$VENV_HOME" 2>/dev/null
}

# New: list registry (name + path)
venvls() {
  if [[ ! -s "$VENV_REGISTRY_FILE" ]]; then
    echo "(no venvs recorded)"
    return 0
  fi
  # nice aligned output
  column -t -s $'\t' "$VENV_REGISTRY_FILE"
}

# Activate venv by recorded name (new behavior).
# If not found in registry, fall back to old layout: $VENV_HOME/<name>
venv() {
  if [ $# -eq 0 ]; then
    echo "Please provide venv name"
    return 1
  fi

  local name="$1"
  local venv_path
  venv_path="$(_venv_registry_get "$name")"

  if [[ -n "$venv_path" && -f "$venv_path/bin/activate" ]]; then
    source "$venv_path/bin/activate"
    return $?
  fi

  if [[ -f "$VENV_HOME/$name/bin/activate" ]]; then
    source "$VENV_HOME/$name/bin/activate"
    return $?
  fi

  echo "venv: not found: $name"
  echo "  - registry: $VENV_REGISTRY_FILE"
  echo "  - checked:  $venv_path"
  echo "  - legacy:   $VENV_HOME/$name"
  return 1
}

# Create venv in CURRENT DIRECTORY as .venv, but keep the old command shape:
#   mkvenv <name>
# It records: <name> -> $(pwd)/.venv
mkvenv() {
  if [ $# -eq 0 ]; then
    echo "Please provide venv name"
    return 1
  fi

  local name="$1"
  local proj_dir
  proj_dir="$(pwd -P)"
  local venv_dir="$proj_dir/.venv"

  local pybin
  pybin="$(_venv_python_bin)"

  if [[ -d "$venv_dir" && -f "$venv_dir/bin/activate" ]]; then
    echo "mkvenv: .venv already exists: $venv_dir"
  else
    "$pybin" -m venv "$venv_dir" || return $?
    echo "mkvenv: created $venv_dir (via $pybin)"
  fi

  _venv_registry_set "$name" "$venv_dir"
  echo "mkvenv: recorded $name -> $venv_dir"
}

# Remove by name: deletes the recorded .venv directory (if present) and removes registry entry.
rmvenv() {
  if [ $# -eq 0 ]; then
    echo "Please provide venv name"
    return 1
  fi

  local name="$1"
  local venv_path
  venv_path="$(_venv_registry_get "$name")"

  if [[ -n "$venv_path" ]]; then
    if [[ -d "$venv_path" && -f "$venv_path/bin/activate" ]]; then
      # Delete the recorded venv directory (matches original "delete record + directory" behavior)
      if command -v trash >/dev/null 2>&1; then
        trash "$venv_path"
        echo "rmvenv: trashed $venv_path"
      else
        rm -rf "$venv_path"
        echo "rmvenv: removed $venv_path"
      fi
    else
      echo "rmvenv: recorded path is missing or not a venv dir (skipped delete): $venv_path"
    fi
    _venv_registry_del "$name"
    echo "rmvenv: removed registry entry for $name"
    return 0
  fi

  # Legacy fallback
  if [[ -d "$VENV_HOME/$name" ]]; then
    rm -rf "$VENV_HOME/$name"
    echo "rmvenv: removed legacy venv $VENV_HOME/$name"
    return 0
  fi

  echo "rmvenv: not found: $name"
  return 1
}
